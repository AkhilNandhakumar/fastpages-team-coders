{
  
    
        "post0": {
            "title": "Grading",
            "content": "Unit 8: 2D Arrays Submissions Grading! . Names Hacks + MCQ FRQ XC Grade out of 1 . Hetvi Trivedi, Brian Tang, Iris Yang | 0.3 | 0.4 | 0 | 0.7 | . Sahil Samar, Rohit De, Nathan Shih, Kurtis Kwan | 0.3 | 0.4 | 0.2 | 0.9 | . Kinish Sathish, Ritvik Keerthi, Samuel Wan, Evverit Cheng | 0.3 | 0.4 | 0.1 | 0.8 | . Andrew Meng, Bailey Say, Rohan Juneja, Nicolas Mounier, Aarav Arora | 0.3 | 0.4 | 0.15 | 0.85 | . Shraddha Kadaba, Bria Gilliam, Calissa Tyrrell, Evan Sanchez | 0.3 | 0.4 | 0.1 | 0.8 | . Ellen Xu | 0.3 | 0.45 | 0.2 | 0.95 | . Linda Liu, Divya Suri | 0.3 | 0.4 | 0 | 0.7 | . Evan Y, Sanja B, Karthik V, Pranav S, Jay M. | 0.3 | 0.4 | 0.2 | 0.9 | . Lily Wu, William Wu | 0.3 | 0.4 | 0.3 | 1 | . Serafina Wong | 0.3 | 0.4 | 0 | 0.7 | . Riya Patil, Vidhi Kulkani | 0.3 | 0.4 | 0.2 | 0.9 | . Gabriel, Avinh, Re’em, Soren | 0.3 | 0.4 | 0 | 0.7 | . Prisha Boreddy | 0.3 | 0.4 | 0 | 0.7 | .",
            "url": "https://akhilnandhakumar.github.io/fastpages-team-coders/2022/12/14/grading.html",
            "relUrl": "/2022/12/14/grading.html",
            "date": " • Dec 14, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Unit 9 - Inheritance",
            "content": "Setup . One of the main goals of learning inheritance is to teach you how to structure your code. So, we&#39;re going to leave a lot of the hacks up to your creativity, and you can make anything you want as long as it follows the structure of inheritance. . Open up a new notebook in your personal fastpages (you can do this in pairs or groups). The hacks in this lesson will be performed from scratch in this notebook. . What is Inheritance, and why is it useful? . Imagine you wanted to create a racing game. You would need a bunch of different cars-bugattis, lamborghinis, rolls royce. Each of these cars would have different features; they would have different fuel types, tires, and engines. A car like an Aston Martin would have a spoiler inside the car for aerodynamics. Lambos have cools doors for when you pull up to a race. But all of these cars would also have a lot in common; all cars have gear shifts, gas, breaks, and steering. . We could model each car with its own class, with attributes and methods specific to each car. But we would find that we&#39;re repeating a lot of the same code over and over - it doesn&#39;t really make sense to redefine the methods for gas and breaks for every single car, when it will do the same thing. . This is a great use case for inheritance. We can define a base &quot;Car Class&quot; that has the methods and attributes common to every car - steering methods, gas and break methods, and attributes like speed and miles per gallon. . Each car will &quot;extend&quot; from this base class. This means that it &quot;inherits&quot; the methods and attributes in the base Car Class (this is why it&#39;s called Inheritance). But each of the new car classes, for example a Bugatti Class, will have its own special methods and attributes. . SuperClasses and Subclasses with Cars . Let&#39;s first look at the base &quot;Car Class&quot; we talked about, with the generic methods all cars would have. This is called the Super Class. . Some vocab: . protected is an access modifier so that the attribute isn&#39;t affected by outside modifiers. . public class Car { protected String brandName; protected double range; protected double doorNumber; protected double maxSpeed; // Constructor for the attributes present in the superclass public Car(String brandName, double range, double doorNumber, double maxSpeed) { this.brandName = brandName; this.range = range; this.doorNumber = doorNumber; this.maxSpeed = maxSpeed; } public void gas () { System.out.println(&quot;Go!&quot;); } public void brake () { System.out.println(&quot;Stop!&quot;); } public void gearShift () { System.out.println(&quot;Use the stick&quot;); } public void steer () { System.out.println(&quot;turning left...&quot;); } public void horn () { System.out.print(&quot;honking... &quot;); } } . public class TeslaModelS extends Car { // Additional attribute not present in the superclass protected String hornSound; // Constructor for Subclass public TeslaModelS(String brandName, double range, double doorNumber, double maxSpeed, String hornSound) { // We use the Superclass constructor for the shared attributes through the keyword &quot;super&quot; super(brandName, range, doorNumber, maxSpeed); // hornSound is not in the Superclass, so we add it separately in the constructor this.hornSound = hornSound; } // We use override to change the functionality in the subclass of an existing method in the superclass @Override public void gearShift () { System.out.println(&quot;Use the gear selector next to the wheel&quot;); } public void steer () { System.out.println(&quot;turning right...&quot;); } // Here, we don&#39;t fully change the functionality of the existing horn method in the superclass // Instead, we take all of the functionality of the superclass method, and then add on to it public void horn () { super.horn(); System.out.println(hornSound); } public static void main(String[] args) { // 5 argument constructor TeslaModelS modelS = new TeslaModelS(&quot;Tesla&quot;, 396, 4, 200, &quot;eugh&quot;); // Example of late binding Car car = new TeslaModelS(&quot;Tesla&quot;, 396, 4, 200, &quot;brrr&quot;); // We can still use the methods from the child class, even though we didn&#39;t mention them in the subclass! modelS.gas(); // Using the overridden method modelS.gearShift(); modelS.steer(); // Using the method we added on to modelS.horn(); car.horn(); } } TeslaModelS.main(null); . Go! Use the gear selector next to the wheel turning right... honking... eugh honking... brrr . Writing Constructors for Subclasses . In the previous example, the TeslaModelS class was a subclass. Recall that a constructor is what initializes the values of the attributes of a class when a new object of the class is created. How do we write constructors for subclasses? . Well, if the attributes of the subclass are exactly the same as the attributes of the superclass, then we can just use the constructor of the superclass. Take a look at the superclass, the Car class. We have defined a constructor within that class already. . To use the constructor of the superclass in our subclass, we need to use some specific syntax. Namely, we need to make use of the super keyword. This allows us to use constructors that we define in the superclass. . Look again at the constructor in the TeslaModelS class. We have passed in 4 attributes to the super constructor, meaning that we are making use of the 4 argument constructor in the superclass. . But our subclass also has an additional attribute: hornSound. We don&#39;t include this in the superclass since this isn&#39;t customizable for most cars. This attribute needs to be included in the constructor for our subclass, but it doesn&#39;t make sense to make a completely new constructor for all 5 attributes when 4 of the attributes are shared with the superclass. . So, what we do is call the superclass constructor with 4 attributes, but then simply add an additional assignment for the 5th, unique, attribute. . Hack 1 . In your own notebook, make any class with 2 attributes and 0 methods. Create a 2 argument constructor for that class. This will be your superclass. Now, create a subclass that extends from the superclass you made. Create 1 additional attribute in your subclass that was not present in the superclass. . Then, create a constructor for the subclass that uses the superclass constructor with the super keyword, and then adds an additional assignment for the third attribute. . Overriding Methods . Overriding allows a subclass or child class to provide a specific implementation of a method that has already been provided by a super-classes or parent classes. When a method in a subclass has the same name, same parameters or signature, and same return type (or sub-type) as a method in its super-class, then the method in the subclass will override the method in the super-class. . . // the existing method in the superclass public void gearShift () { System.out.println(&quot;Use the stick&quot;); } public void steer () { System.out.println(&quot;turning left...&quot;); } // We use override to change the functionality in the subclass of an existing method in the superclass @Override public void gearShift () { System.out.println(&quot;Use the gear selector next to the wheel&quot;); } public void steer () { System.out.println(&quot;turning right...&quot;); } . Hack 2 . Add a method to the superclass you created before. This method should be very general; it should only have functionality that you know for sure will be needed in almost every single subclass. In your subclass, override this method. Remember that overriding the method will give your subclass the specific functionality it needs from that method. . Super Keyword . The two main uses of the super keyword are to use constructors in the superclass and methods in the superclass in a child class. . In this example child class TeslaModelS, the super keyword can be found in the constructor and the method horn. When it says, super(brandName, range, doorNumber, maxSpeed) in the constructor, the super keyword is used to utilize the super class constructor inside the child class. Next, in the horn() method, super.horn() is called. This line utilizes the super keyword to call the method horn() from the parent class Car. . Creating References Using Inheritance Hierarchies . Type Diagram . It is similar to looking at it like a family tree. A is the superclass, or the head of the family. The descendants are the subclasses. . So . public class A public class B extends A public class C extends B . A Reference refers to an object of the class, or the object of an inherited class. So an Inheritance Hierarchy can create references . . Polymorphism . public class ToyotaCamry extends Car { public ToyotaCamry (String brandName, double range, double doorNumber, double maxSpeed) { super(brandName, range, doorNumber, maxSpeed); } @Override public void gearShift () { System.out.println(&quot;Manual shift!&quot;); } public void turbo (int a) { System.out.println(&quot;Engaging turbo &quot; + a); } public void turbo (int a, int b) { System.out.println(&quot;Engaging turbo &quot; + a + &quot; and nitro &quot; + b); } public static void main(String[] args) { // 4 superclass argument constructor ToyotaCamry camry = new ToyotaCamry(&quot;Toyota&quot;, 348, 4, 145); // Using the overridden method camry.gearShift(); // Using the overloaded method camry.turbo(1); camry.turbo(1, 1); } } ToyotaCamry.main(null); . Manual shift! Engaging turbo 1 Engaging turbo 1 and nitro 1 . Polymorphism means &quot;many forms&quot;. It means that we do one thing in many ways through inheritance. . For example, the gearShift method defined in the superclass simply says to use the stick. But in manual cars and a Tesla, you need to do different things. So, we show the method to shift gears being used in two different ways in two different classes. We can have two different implementations through overriding methods. . Look at the different outputs for the method in the ToyotaCamry and TeslaModelS class. . This method of polymorphism is called Runtime Polymorphism. It is also called Dynamic Binding or Dynamic Method Dispatch. When you hear any of these things, think of method overriding. . Imagine if you want to do a single method in a single class, but in different ways. For example, in the ToyotaCamry class, we need to either engage a turbo by itself, or a turbo with a nitro. So, we have two methods called turbo. When the method is called, the actual functionality is resolved at compile-time. . When we call camry.turbo(1), then the single argument turbo method is called. When we call camry.turbo(1, 1), the two argument turbo method is called. . Having two methods with the same name but different arguments and functionalities is called method overloading. . This is another form of polymorphism called Compile Time Polymorphism or Static Polymorphism. When you see these terms, think of method overloading. . Early binding has to do with when the compiler decides the method to be called. Relate this to Static Polymorphism or method overloading. Late binding has to do with when the method is decided at runtime. Relate this to Runtime Polymorphism or method overriding. . Hack 3 . Create another subclass from your original superclass. Now, implement method overloading in this subclass. Remember that this means having two methods with the same name, but with different arguments. The method you are using for method overloading doesn&#39;t have to exist in the superclass. This will implement Static Polymorphism. . Next, override the method in your superclass in your new subclass. Make sure it has different functionality than your method in the other subclass. This will implement Runtime Polymorphism. . Object Superclass . Important Things to Know . Object class is the superclass of all other classes in Java | Object is part of the java.lang package (know for imports) | Important Object class methods include: boolean equals(Object x) &amp; String toString() | Object class&#39; subclasses override the equals and toString methods | . toString Method . Prints out the attributes of an object | Converts string object into a string | . equals Method . Compares two strings | Returns a boolean value of true if equal, otherwise returns false | . // Demonstration of toString method // Utilized toString methods in all FRQs so far, here&#39;s an example from FRQ1 public String dayOfWeekToString() { return (&quot;{ &quot;month &quot;: &quot; + this.month + &quot;, &quot; + &quot; &quot;day &quot;: &quot; + this.day + &quot;, &quot; + &quot; &quot;year &quot;: &quot; + this.year + &quot;, &quot; + &quot; &quot;dayOfWeek &quot;: &quot; + this.dayOfWeek + &quot; }&quot;); } public String toString() { return dayOfWeekToString(); } . // Demonstration of equals method // Outputs boolean value of true or false // If one object equals another public class Student { private String name; public Student(String name) { this.name = name; } public static void main(String[] args) { Student student1 = new Student(&quot;Bob&quot;); Student student2 = new Student(&quot;Jeff&quot;); Student student3 = student1; Student student4 = new Student(&quot;A&quot;); Student student5 = student4; System.out.println(student1.equals(student2)); System.out.println(student2.equals(student3)); System.out.println(student1.equals(student3)); System.out.println(student3.equals(student4)); System.out.println(student3.equals(student4)); System.out.println(student5.equals(student4)); } } Student.main(null); . false false true false false true . Final Homework . Polish up all of the hacks from this lesson. Completed hacks will earn you 0.9/1. . For 1/1, submit a complete blog. This means highlighting all key vocabulary, and including original comments in your code to show understanding. This will also help you for Mr. Mort&#39;s live review on Thursday. . Grades . Team Grade Reason . 1: Lily Wu, William Wu, Vidhi Kulkarni, Riya Patil, Saathvika Ajith | 1/1 | Hacks are performed correctly with interesting use case of Cats. Really good blog with vocab definitions and some code comments. | . 2: | b | y | . 3 | c | z | . 4 | d | a | . 5: Kinish Sathish, Ritvik Keerthi, Samuel Wang, Everitt Cheng | 1/1 | Hacks are all done with inheritance use case of animals. Good work on adding comments in code that show understanding, as well as complete blog with vocab. | . 7: Shraddha, Bria, Calissa, Evan | 1/1 | Hacks are performed correctly with candy inheritance example. Also included notes on key terms. | . 8: Bailey Say, Andrew Meng, Nicholas Mounier, Rohan Juneja, Aarav Arora | 0.95/1 | Good work on identifying a use case for inheritance and creating a detailed blog with vocabulary. The only thing missing is finishing Hack 3, which would require two subclasses to implement Runtime Polymorphism. | . 9: Hetvi Trivedi, Brian Tang, Iris Yang, and Ellen Xu | 1/1 | Hacks are performed correctly with interesting use case of Iphones. Covered all of the important vocabulary in blog as well. | .",
            "url": "https://akhilnandhakumar.github.io/fastpages-team-coders/cb/2022/12/13/unit9-notes.html",
            "relUrl": "/cb/2022/12/13/unit9-notes.html",
            "date": " • Dec 13, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Unit 10 - Recursion",
            "content": "A recursive method is a method that calls itself - a subproblem that calls itself repeatedly | . Two parts to the method: . a base case | recursive call | . After multiple calls, the base case is reached where recursion is stopped and a value is returned . Should be written first to avoid infinite recursion . //example of base case int fact(int n) { if (n &lt; = 1) // base case return 1; else return n*fact(n-1); } . Binary Search . Binary search algorithm | Data must be in sorted order | Keeps halving array until value is found | More efficient than linear search (O(log2n) vs O(n)) | . Big O notation . How long an algorithm takes to run | HashMap has O(1) which is same amount of time to execute | Binary Search has O(log N) which means it takes an additional step each time data doubles | Single and Nested loop is O(1) | . // Java Program to Illustrate Recursive Binary Search import java.util.*; // Main class class Binary { // Recursive binary search // Returns index of x if it is present // in arr[l..r], else return -1 int binarySearch(int arr[], int l, int r, int x) { // Restrict the boundary of right index // and the left index to prevent // overflow of indices if (r &gt;= l &amp;&amp; l &lt;= arr.length - 1) { int mid = l + (r - l) / 2; // If the element is present // at the middle itself if (arr[mid] == x) return mid; // If element is smaller than mid, then it can // only be present in left subarray if (arr[mid] &gt; x) return binarySearch(arr, l, mid - 1, x); // Else the element can only be present // in right subarray return binarySearch(arr, mid + 1, r, x); } // We reach here when element is not present in // array return -1; } } . Linear Recursion . A function that only makes a single call to itself each time the function runs (as opposed to one that would call itself multiple times during its execution) . Selection Sort: The algorithm works by repeatedly finding the minimum element (considering ascending order) from the unsorted part and putting it at the end of the sorted part . | Merge Sort: It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves . | .",
            "url": "https://akhilnandhakumar.github.io/fastpages-team-coders/fastpages/lessonhw/2022/12/13/unit10-notes.html",
            "relUrl": "/fastpages/lessonhw/2022/12/13/unit10-notes.html",
            "date": " • Dec 13, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "CollegeBoard FRQ 4",
            "content": "2D Array Vocab: . Array = a data structure used to implement a collection (list) of primitive or object reference data an example: | . | . public class Test { public static void main(String[] args) { int[][] arr = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; System.out.println(&quot;arr[0][0] = &quot; + arr[0][0]); System.out.println(&quot;arr[1][2] = &quot; + arr[1][2]); System.out.println(&quot;arr[2][1] = &quot; + arr[2][1]); } } Test.main(null); . arr[0][0] = 1 arr[1][2] = 6 arr[2][1] = 8 . Element = a single value in the array | Index = the position of the element in the array (starts from 0) | Array Length = the number of elements in the array Is public, so can be accessed in any class | Is also final, so can’t change it after array has been created | . | Nested Loops = A nested loop is a loop within a loop, an inner loop within the body of an outer one an example: | . | . public class Test { public static void main(String[] args) { String[][] arr = { { &quot;a&quot;, &quot;f&quot;, &quot;g&quot;, &quot;l&quot; }, { &quot;b&quot;, &quot;e&quot;, &quot;h&quot;, &quot;k&quot; }, { &quot;c&quot;, &quot;d&quot;, &quot;i&quot;, &quot;j&quot; } }; for (int row = 0; row &lt; 3; row++) { for (int col = 0; col &lt; 4; col++) { System.out.print(arr[row][col] + &quot; &quot;); } System.out.println(&quot; &quot;); } } } Test.main(null); . FRQ 4: . public class LightBoard { /** The lights on the board, where true represents on and false represents off. */ private boolean[][] lights; /** Constructs a LightBoard object having numRows rows and numCols columns. * Precondition: numRows &gt; 0, numCols &gt; 0 * Postcondition: each light has a 40% probability of being set to on. */ public LightBoard(int numRows, int numCols) { /* to be implemented in part (a) */ } /** Evaluates a light in row index row and column index col and returns a status * as described in part (b). * Precondition: row and col are valid indexes in lights. */ public boolean evaluateLight(int row, int col) { /* to be implemented in part (b) */ } // There may be additional instance variables, constructors, and methods not shown. } . part a . public LightBoard(int numRows, int numCols) { lights = new boolean[numRows][numCols]; // use of nested loops to iterate through the array elements for(int r = 0; r &lt; lights.length; r++) { for(int c = 0; c &lt; lights[0].length; c++) { if(Math.random() &lt;= 0.4) lights[r][c] = true; } } } . part b . public boolean evaluateLight(int row, int col) { // sets initial to 0 int onInColumn = 0; // finds how many lights are on for(int r = 0; r &lt; lights.length; r++) { if(lights[r][col] == true) { onInColumn++; } } // decides if the conditions match true or false if(lights[row][col]) { if(onInColumn % 2 == 0) { return false; } } else { if(onInColumn % 3 == 0) { return true; } } return lights[row][col]; } .",
            "url": "https://akhilnandhakumar.github.io/fastpages-team-coders/jupyter/2022/12/11/FRQ4.html",
            "relUrl": "/jupyter/2022/12/11/FRQ4.html",
            "date": " • Dec 11, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Unit 7 - Array Lists",
            "content": "Lesson Purpose and Objectives . Learn about the structure and functions of an arrayList and go over the key College Board concepts for arrayLists . ArrayLists are only 2.5%-7.5% but have many concepts from other units and are a good data structure to know. Also, the 3rd question of the FRQ is based on ArrayLists . 7.1 Introduction to ArrayList . Arrays ArrayLists . Static (fixed size) | Dynamic (can change size) | . Fundamental java feature | Part of a framework. Someone was nice and designed this with the behind the scenes being arrays | . An object with no methods | A class with many methods | . Not as flexible | Designed to be more flexible | . Can store more primitive data | Not designed to store primitives, they store object references | . | Slightly slower than Arrays | . | Can only be used with an import statement | . Real Life Array Example: You always have to have five players on the court . Real Life ArrayList Example: In dodgeball, the number of people in the game is changing based on who comes in or gets out . Primitive Data Types: . boolean | char | double | int | . Wrapper Class Data Types (Store the primitive values as objects) . Boolean | Character | Double | Integer | . import java.util.ArrayList; //you must import the java.util package // Instantiating: ArrayList&lt;DataType&gt; variableName = new ArrayList&lt;&gt;(n); //DataType must be nonprimitive data type public class introArrayList { public static void main (String[] args) { ArrayList&lt;Integer&gt; e1 = new ArrayList&lt;Integer&gt;(); //empty ArrayList&lt;String&gt; e2 = new ArrayList&lt;String&gt;(5); //5 elements ArrayList&lt;Dogs&gt; e3 = new ArrayList&lt;Dogs&gt;(); //you can store whatever objects you want } } . 7.2 ArrayList Methods . There are a lot of cool methods that you can use with arrayLists, but here are the ones College Board wants you to know for 7.2 - . size(); . Returns the number of elements in the list | . add(obj); . Adds element at the end | . add(index, object); . Adds element at specific index | . remove(index); . Removes element from specific index | . set(index, object); . Replaces element at index with new object | . get(index); . Returns element at index | . import java.util.ArrayList; public class methodsArrayList { public static void main (String[] args) { ArrayList&lt;String&gt; dogs = new ArrayList&lt;String&gt;(Arrays.asList(&quot;Sparky&quot;, &quot;Duke&quot;, &quot;Noodle&quot;)); ArrayList&lt;String&gt; dogs2 = new ArrayList&lt;&gt;(Arrays.asList(&quot;Sparky&quot;, &quot;Duke&quot;, &quot;Noodle&quot;)); System.out.println(&quot;There are &quot; + dogs.size() + &quot; in the ArrayList&quot;); System.out.println(&quot;There are &quot; + dogs2.size() + &quot; in the ArrayList&quot;); //objects you add must be of the same data type dogs.add(&quot;Peanut&quot;); System.out.println(&quot;There are now &quot; + dogs.size() + &quot; dogs in the ArrayList&quot;); String myDog = dogs.get(2); System.out.println(&quot;My dog is named &quot; + myDog); } } //Note: you don&#39;t need to declare &lt;String&gt; again after new ArrayList methodsArrayList.main(null); . There are 3 in the ArrayList There are 3 in the ArrayList There are now 4 dogs in the ArrayList My dog is named Noodle . //Hmmmm... seems suspect import java.util.ArrayList; public class example { public static void main (String[] args) { ArrayList&lt;Boolean&gt; questions = new ArrayList&lt;&gt;(); questions.add(true); questions.add(false); myMethod(questions); } public static void myMethod(ArrayList arr) { if (arr.size()&gt;0) { arr.set(0,&quot;Hello&quot;); //String with boolean??? Uh oh! System.out.println(arr.get(0)); } } } example.main(null); . Hello . import java.util.ArrayList; public class example { public static void main (String[] args) { ArrayList&lt;Boolean&gt; questions = new ArrayList&lt;&gt;(); questions.add(true); questions.add(false); myMethod(questions); } public static void myMethod(ArrayList&lt;Boolean&gt; arr) { if (arr.size()&gt;0) { arr.set(0,&quot;Hello&quot;); //String with boolean??? Uh oh! System.out.println(arr.get(0)); } } } example.main(null); //Make sure to specify data type so the compiler is more helpful and it avoids confusion //This also applies for returning and arrayList as well . | arr.set(0,&#34;Hello&#34;); //String with boolean??? Uh oh! incompatible types: java.lang.String cannot be converted to java.lang.Boolean . //Returning an ArrayList public static ArrayList methodName (ArrayList arr){ return arr; } . // HACK!!!! // Create an arrayList and use one of the cool methods for it import java.util.ArrayList; public class hack1 { public static void main (String[] args) { ArrayList&lt;String&gt; cats = new ArrayList&lt;&gt;(Arrays.asList(&quot;Princess&quot;, &quot;Fluffy&quot;, &quot;Captain&quot;)); System.out.println(&quot;There are &quot; + cats.size() + &quot; in the ArrayList&quot;); //objects you add must be of the same data type cats.add(&quot;Angelina&quot;); System.out.println(&quot;There are now &quot; + cats.size() + &quot; cats in the ArrayList&quot;); } } hack1.main(null); . There are 3 in the ArrayList There are now 4 cats in the ArrayList . 7.3 Traversing ArrayLists . there are 2 ways to traverse arraylists: for loops and enhanced for loops | use get() instead of bracket notation for getting an element of an arraylist | use size() to find number of elements in arraylist instead of using .length | . for loop . import java.util.*; public class main { public static void main(String[] args) { List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5); for (int i = 0; i &lt; numbers.size(); i++) { System.out.print(numbers.get(i) + &quot; &quot;); } } } main.main(null); . 1 2 3 4 5 . enhance for loops . import java.util.*; public class main { public static void main(String[] args) { List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5); for ( int num : numbers ) System.out.print(num + &quot; &quot;); } } main.main(null); . 1 2 3 4 5 . Common Mistakes . don&#39;t forget to import java.util.ArrayList | don&#39;t declare or instantiate ArrayList with a primitive data type, which are things such as int, double, and booleans. | don&#39;t forget the parentheses at the end of the constructor and the element types with the brackets: ArrayList list = new ArrayList(); &lt;/li&gt; don&#39;t confuse arrays with arraylists, don&#39;t use [], don&#39;t use .length use .size() instead | &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Hack #2 . import java.util.ArrayList; ArrayList&lt;String&gt; color = new ArrayList&lt;String&gt;(); color.add(&quot;red apple&quot;); color.add(&quot;green box&quot;); color.add(&quot;blue water&quot;); color.add(&quot;red panda&quot;); /*/ using if(color.get(i).contains(&quot;red&quot;)) iterate through the arraylist and remove all elements that contain the word red in them /*/ for (int i = 0; i &lt; color.size(); i++) { if (color.get(i).contains(&quot;red&quot;)) { color.remove(i); } } System.out.print(color); . [green box, blue water] . 7.4 Developing Algorithms Using ArrayLists . Modify Array Values . ArrayList&lt;Integer&gt; num = new ArrayList&lt;Integer&gt;(); num.add(5); num.add(1); num.add(3); for (int i = 0; i &lt; num.size(); i++) { num.set(i, num.get(i) * 2); } System.out.print(num); . [10, 2, 6] . find max value . ArrayList&lt;Integer&gt; num = new ArrayList&lt;Integer&gt;(); num.add(5); num.add(1); num.add(3); int maxValue = num.get(0); for (int number: num) { if (number &gt; maxValue) { maxValue = number; } } System.out.print(maxValue); . 5 . find min value . ArrayList&lt;Integer&gt; num = new ArrayList&lt;Integer&gt;(); num.add(5); num.add(1); num.add(3); int minValue = num.get(0); for (int number: num) { if (number &lt; minValue) { //if new min value found, replace current minValue minValue = number; } } System.out.print(minValue); . 1 . Hack #3 . // find the sum of the elements in the arraylist ArrayList&lt;Integer&gt; num = new ArrayList&lt;Integer&gt;(); num.add(5); num.add(1); num.add(3); int sum = 0; for (int i = 0; i &lt; num.size(); i++) { sum = sum + num.get(i); } System.out.print(sum); . 9 . 7.5 Searching . Often times we need to locate data inside linear structures. Normally we would use for loops in order to specify each element, one at a time, and do not need to track the index after execution. | . for ( int index = 0; index &lt; items.size(); index++ ){ //forward searching if ( items.get(index) == num ){ return index; } } . Important Things to Keep in Mind . When looking at int values, the == operator should be used. | When searching for a double value, we need to make sure the value is close enough by doing some math. | Object instances should always use the .equals(otherThing) method to check for a match. | . When searching a linear structure we need to send it the structure and what we are looking for as parameters. A standard for loop with an if block is all we need to search any linear structure. . public int whereIsMyNumber(int magicNumber, int [] myNumbers) { for (int index = 0; index &lt; myNumbers.length; index++) //search through every single spot { if (myNumbers[index] == magicNumber) //do they match? if so return index { return index; } } return -1; // if searched through every single spot, indicate its not there } . You shouldn&#39;t use the == operator when looking for an object. It will only return true if the variable and the element stored at the index point to the same memory, are aliases of each other. | . Here is an example of how you would search for a traditional object: . public int findTheWord(String searchedPhrase, ArrayList&lt;Book&gt; myBooks) { for (int index = 0; index &lt; myBooks.size(); index++) //search through every book in structure { Book currentBook = myBooks.get(index); //hold current book with current book variable String currentPhrase = currentBook.getDescription(); //get description of current book and store in variable currentPhrase if (currentPhrase.equals(searchedPhrase)) //if parameter = current phrase of book looking at - using .equals instead of == operator { return index; } } return -1; //if no match found, indicate its not there } . 7.6 Sorting . Selection sort identifies either the maximum or minimum of the compared values and iterates over the structure checking if the item stored at the index matches the condition, if so, it will swap the value stored at the index and continue. | The insertion sort is characterized by building a sorted structure as it proceeds. It inserts each value it finds at the appropriate location in the data structure. This is often accomplished by using a while loop as the inner loop. | . for (int outer = 1; outer &lt; randomList.size(); outer++) { DebugDuck tested = randomList.get(outer); //extract out a value out of list, passes to outer int inner = outer - 1; //goes back and compares to previous while ( inner &gt;= 0 &amp;&amp; tested.compareTo(randomList.get(inner)) &lt; 0 ) //checks to see if index is valid { randomList.set(inner + 1, randomList.get(inner)); //move up by one and replace original location inner--; } randomList.set(inner + 1, tested); //anything taken out would be placed back into structure } . 7.7 Ethical Issues Around Data Collection . Safety with Data Collection . It is very important to minimize user data collection in our programs. While collecting data in a smaller program may not be a big issue, establishing good practices with data security is always a safer bet when eventually moving to larger projects that manage data. . Whenever you come across data that you no longer will need, it is a good practice to explicitly remove that data altogether. . import java.util.Scanner; import java.util.Arrays; public class dataRemoval { public static void main(String[] args) { // just a scanner object Scanner sc = new Scanner(System.in); // makes an arraylist with some users already in it ArrayList&lt;String&gt; userList = new ArrayList&lt;&gt;(Arrays.asList(&quot;Kian&quot;, &quot;Kiannp44@gmail.com&quot;, &quot;Samuel&quot;, &quot;samuelwaang@gmail.com&quot;, &quot;Calissa&quot;, &quot;calissaT@gmail.com&quot;)); // takes user&#39;s name System.out.println(&quot;Log in &quot;); System.out.println(&quot;Please enter your name:&quot;); String name = sc.nextLine(); System.out.println(name); userList.add(name); // takes user&#39;s email System.out.println(&quot;Please enter your email:&quot;); String email = sc.nextLine(); System.out.println(email); userList.add(email); // prints all the current users in arraylist System.out.println(); System.out.println(&quot;Current users in database &quot;); System.out.println(userList); // prompt to log out System.out.println(); System.out.println(&quot;Would you like to log out? (y/n)&quot;); String logOut = sc.nextLine(); if (logOut.equals(&quot;y&quot;)) { // if user logs out, remove their name and email from arraylist System.out.println(logOut); userList.remove(name); userList.remove(email); } // reprints current users in arraylist System.out.println(); System.out.println(&quot;Current users in database &quot;); System.out.println(userList); } } dataRemoval.main(null); . Log in Please enter your name: Evan Please enter your email: evanjoelsanchez@gmail.com Current users in databse [Kian, Kiannp44@gmail.com, Samuel, samuelwaang@gmail.com, Calissa, calissaT@gmail.com, Evan, evanjoelsanchez@gmail.com] Would you like to log out? (y/n) y Current users in database [Kian, Kiannp44@gmail.com, Samuel, samuelwaang@gmail.com, Calissa, calissaT@gmail.com] . Anonymizing Personal Data . Instead of using names for users, we can use hash codes instead, which means that each user will simply be identified by their hash code. . public class hashUsers { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String name = sc.nextLine(); // this .hashCode() method will convert the name to a code which cannot be traced back to that original name int id = name.hashCode(); name = null; // name is now null, and nobody will ever know the original name I put in System.out.println(&quot;Hash Code: &quot; + id); } } hashUsers.main(null); . Hash Code: 2172094 . The Takeaway . It is important to understand that as a programmer handling user data, it is your responsibility to protect that collected data. The less data you collect, the less you have to safeguard. A compromised database will generally be an expensive lawsuit in a large scale project. . Homework . Quizziz . Completed . &lt;/div&gt; | .",
            "url": "https://akhilnandhakumar.github.io/fastpages-team-coders/jupyter/2022/11/30/unit7-notes.html",
            "relUrl": "/jupyter/2022/11/30/unit7-notes.html",
            "date": " • Nov 30, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Unit 8 - 2D Arrays",
            "content": "Learning Objective! . Represent collections of related primitive and object reference data using two dimensional array objects. . 2D Array Vocab: . Array = a data structure used to implement a collection (list) of primitive or object reference data | Element = a single value in the array | Index = the position of the element in the array (starts from 0) | Array Length = the number of elements in the array Is public, so can be accessed in any class | Is also final, so can’t change it after array has been created | . | . The Basics: . A 2D array is an array of arrays, and can be a better way to store data | Declaring a 2D array: DataType[][] nameOf2DArray | . | Initializing a 2D array DataType[][] nameOf2DArray = new DataType[r][c]; r = # of rows The # of arrays in the array | r = list.length c = # of columns | . | The # of elements in the inner arrays | c = list[0].length | . | . | . | . Initializing a Sample Array: . public class Test { public static void main(String[] args) { int[][] arr = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; System.out.println(&quot;arr[0][0] = &quot; + arr[0][0]); System.out.println(&quot;arr[1][2] = &quot; + arr[1][2]); System.out.println(&quot;arr[2][1] = &quot; + arr[2][1]); } } Test.main(null); . arr[0][0] = 1 arr[2][0] = 6 arr[2][1] = 8 . Accessing and Updating Elements of a 2D Array: . nameOf2DArray[r][c] | . Hack 1: Access the last element of the 2D Array list: . public class Test { public static void main(String[] args) { String[][] arr = { { &quot;a&quot;, &quot;f&quot;, &quot;g&quot; }, { &quot;b&quot;, &quot;e&quot;, &quot;h&quot; }, { &quot;c&quot;, &quot;d&quot;, &quot;i&quot; } }; // Print the last element in the array! } } Test.main(null); . a quick tip for the future: list[list.length - 1][list[0].length - 1] | Updating an element: list[r][c] = value; | . | . Hack 2: Changing a Value: . public class Test { public static void main(String[] args) { String[][] arr = { { &quot;Atlanta&quot;, &quot;Baltimore&quot;, &quot;Chicago&quot; }, { &quot;Australia&quot;, &quot;Boston&quot;, &quot;Cincinnati&quot; }, { &quot;Austin&quot;, &quot;Beaumont&quot;, &quot;Columbus&quot; } }; // Change Austin to Athens and print! System.out.println(&quot;Change Austin to Athens and print!&quot;); } } Test.main(null); . Change Austin to Athens and print! . Nested Loops, Our Beloved: . You can use Nested Loops to traverse 2D Arrays for example: to print out an entire array in order, you need to use these | . | . public class Test { public static void main(String[] args) { String[][] arr = { { &quot;a&quot;, &quot;f&quot;, &quot;g&quot;, &quot;l&quot; }, { &quot;b&quot;, &quot;e&quot;, &quot;h&quot;, &quot;k&quot; }, { &quot;c&quot;, &quot;d&quot;, &quot;i&quot;, &quot;j&quot; } }; for (int row = 0; row &lt; 3; row++) { for (int col = 0; col &lt; 4; col++) { System.out.print(arr[row][col] + &quot; &quot;); } System.out.println(&quot; &quot;); } } } Test.main(null); . a f g l b e h k c d i j . Make sure your columns for loop is always inside your rows for loop! Unless you want it printed the other way of course | . | Print spaces and lines in between to make a neater matrix | . Hack 3: Unknown Dimensions: . public class Test { public static void main(String[] args) { String[][] arr = { { &quot;Atlanta&quot;, &quot;Baltimore&quot;, &quot;Chicago&quot; }, { &quot;Australia&quot;, &quot;Boston&quot;, &quot;Cincinnati&quot; }, { &quot;Austin&quot;, &quot;Beaumont&quot;, &quot;Columbus&quot; } }; // Print out the array without using numerical values! } } Test.main(null); . Searching for a Value in a 2D Array: . Here&#39;s a quick example to illustrate: | . public class Test { public static void main(String[] args) { String[][] arr = { { &quot;Atlanta&quot;, &quot;Baltimore&quot;, &quot;Chicago&quot; }, { &quot;Australia&quot;, &quot;Boston&quot;, &quot;Cincinnati&quot; }, { &quot;Austin&quot;, &quot;Beaumont&quot;, &quot;Columbus&quot; } }; String match = &quot;&quot;; String name = &quot;Boston&quot;; for (String[] row : arr) { for (String item : row) { if (item.equals(name)) { match = name; } } } if (match.length() == 0) { System.out.println(&quot;No Match!&quot;); } else { System.out.println(name); } } } Test.main(null); . Boston . Note: in the code, you see the use of : which essentially means within. | . Hack 4: Finding the Min/Max Value: . public class Test { public static void main(String[] args) { String[][] arr = { { &quot;Atlanta&quot;, &quot;Baltimore&quot;, &quot;Chicago&quot; }, { &quot;Australia&quot;, &quot;Boston&quot;, &quot;Cincinnati&quot; }, { &quot;Austin&quot;, &quot;Beaumont&quot;, &quot;Columbus&quot; } }; String longest = arr[0][0]; // Use nested for loops to find the longest or shortest string! System.out.println(&quot;Use nested for loops to find the longest or shortest string!&quot;); } } Test.main(null); . Use nested for loops to find the longest string! . HW! . Please submit screenshots of your 4 hacks up and running to our Google Form, which also has a few 2D array related multiple choice questions. . Additionally, Complete and send a screenshot of your code for 2017 FRQ Q4: Successor Array in that same google form. . Please submit as a pair or group. .",
            "url": "https://akhilnandhakumar.github.io/fastpages-team-coders/jupyter/2022/10/27/2DArray.html",
            "relUrl": "/jupyter/2022/10/27/2DArray.html",
            "date": " • Oct 27, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Unit 6 - Arrays",
            "content": "Arrays Overview . Arrays are 10-15% of the AP CSA Exam | The four main topics that College Board wants you to know Array creation and access | Traversing arrays | Enhanced for loops for arrays | Developing algorithms using arrays | . | The overall purpose of arrays is to store multiple values in a single variable, instead of declaring separate variables for each value. | . 6.1 Array Creation and Access . Arrays are used to store one data type | Unlike Arraylists, arrays have a fixed size and cannot be changed | Arrays can be denoted using braces {} Below is an example of a simple array storing our scrum team names [Meena, Shraddha, Madhumita, Pranavi] . | To use an array you have to use the command import java.util.Arrays; . | . Making Arrays . There are two ways to make arrays . using constructors | using pre-intiliazed arrays | . dataType[] arrayName = new dataType[numberOfItems]; //Constructor int[] arraySample = {1,3,5,7,9}; //pre-initialized arrays . Accessing Elements in Arrays . You can access the elements in an array using different commands | . arrayName.Length //determine the size arrayName.length - 1 //to access the last item in the array . 6.2 Traversing Arrays . Traversing is accessing every value in the array | Can be done using a loop like a for loop or while loop | Below is an example - using a for loop, we can iterate through each fruit in the array of Strings and print it out | . // Here is the array we will be working with String[] myFruits = new String[] {&quot;Apple&quot;, &quot;Strawberry&quot;, &quot;Watermelon&quot;, &quot;Blueberry&quot;}; for (int i = 0; i &lt; myFruits.length; i++) { System.out.println(&quot;Fruit number &quot; + i + &quot; is &quot; + myFruits[i]); } . Can also loop through an array in reverse | . for (int i = myFruits.length - 1; i &gt;= 0 ; i--) { System.out.println(&quot;Fruit number &quot; + i + &quot; is &quot; + myFruits[i]); } . If we have a list of numbers, we could change each value in the array by a certain amount | . // Here is the array we will be working with int[] myNumbers = new int[] {1, 3, 5, 7, 9}; for (int i = 0; i &lt; myNumbers.length; i++) { // add 10 to each element in the array myNumbers[i] += 10; System.out.println(&quot;New element &quot; + i + &quot; is &quot; + myNumbers[i]); } . We can also traverse an array using a while loop | . // Here is the array we will be working with String[] myFruits = new String[] {&quot;Apple&quot;, &quot;Strawberry&quot;, &quot;Watermelon&quot;, &quot;Blueberry&quot;}; int i = 0; while (i &lt; myFruits.length) { System.out.println(&quot;Fruit number &quot; + i + &quot; is &quot; + myFruits[i]); i++; } . Bound Errors . ArrayIndexOutOfBoundsException thrown, can happen when using loops to access array elements | In the example below instead of the condition being while the index is less than the length of the array, the condition is less than or equal too | This mean the loop will try to run when i = 4 (since the length of the list is 4). However since array index starts from 0, the last item in the array will have an index of 3. So, index of 4 will be out of bounds, resulting in the error. | . int i = 0; while (i &lt;= myFruits.length) { System.out.println(&quot;Fruit number &quot; + i + &quot; is &quot; + myFruits[i]); i++; } . 6.3 Enhanced for loop for Arrays . This topic was pretty short, but essentially what you need to know is about the enhanced for loop. The enhanced for loop can be used to traverse through most data structures (i.g. arrays). However, it can only traverse in a forward direction. Usually the structure is like so . for (dataType i: arrayName) { do something with i } . Essentially, this code mentions how every element in the array (i) has to have something done to it. It&#39;s important to note that although there is access to the element i, but it isn&#39;t possible to change the value/set new values to element i. . We can use mutator methods on objects on the array to set the value of their instance variables. This is because i is a copy of the object reference, which means that i refers to the same object as the array element, so calling methods on i is the same as calling methods on the individual array elements themselves. For example . public class Student { private String name; /** Sets the name of the Student */ public void setName(String name) { this.name = name; } /** Other instance variables, methods, and constructors not shown */ } // IN ANOTHER CLASS /** Resets all students&#39; names */ public static void doubleArray(Student[] array, String defaultName) { for (Student student: array) { student.setName(defaultName); // Sets each student&#39;s name to a default name } } . 6.4 Developing Algorithms using Arrays . Here are some algorithms that arrays can be used for (from college board standards), . Minimum and Maximum of a list of elements | Compute the sum, average, or mode of multiple elements | Determine if at least one element has a property | Access consecutive pairs of elements | Determine duplicates | . What to use when problem solving with arrays .length can be used to find the length of an array . The value at a specific index can be found with array[i], where i is the index | An element at index i can be replaced using array[i] = new element | You can iterate over an array with a for loop for(type element: array) { code here . | . Computing Sums with Arrays . See the code below for a sample algorithm of how to compute the sum of elements in an array. This could be applied to finding the mean, standard deviation, or any other algorithm that requires summation. . int[] array = {5, 1, 78}; // intialize int sum = 0; // variable to keep track of sum for (int number; array) { // iterates over each loop in the array sum += number; // the number is added to the sum } System.out.println(sum); //expected sum is 84, so 84 should be printed . Find the max . // from college board private double findMax(double[] values) { double max = values[0]; // initialize max with first element of array for(int i=1; i&lt;values.length; i++) { // starting with the second element, iterate over the rest of the array if (values[i] &gt; max) { // if the current element is greater than the max max = values[i]; // set the max equal to the greatest value until that point } } return max; } . Find the amount of even numbers. . private int findEvenNumbers(int[] values) { int evenCount = 0; // initalize count of even numbers to zero for(int value: values) { // iterate over every element of array if(value % 2 == 0) { // use modulus operator to check if value is even evenCount += 1; // increment evenCount if the value is even } } return evenCount; } . Homework . HW Google Form submitted as pair with Re&#39;em. . public void addMembers(String[] names, int gradYear) { for (int i = 0; i &lt; names.length; i++) { String memberName = names[i]; memberList.add(memberName, memberName.getGradYear, true); } } .",
            "url": "https://akhilnandhakumar.github.io/fastpages-team-coders/jupyter/2022/10/25/unit6-notes.html",
            "relUrl": "/jupyter/2022/10/25/unit6-notes.html",
            "date": " • Oct 25, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://akhilnandhakumar.github.io/fastpages-team-coders/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://akhilnandhakumar.github.io/fastpages-team-coders/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}